// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.gen.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const authServiceDeleteAllUserSessions = `-- name: AuthServiceDeleteAllUserSessions :exec

DELETE FROM sessions WHERE user_id = $1
`

// This file is auto-generated by /home/pgbackweb/scripts/sqlc-prebuild.ts. DO NOT EDIT.
// file: /home/pgbackweb/internal/service/auth/delete_all_user_sessions.sql
func (q *Queries) AuthServiceDeleteAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, authServiceDeleteAllUserSessions, userID)
	return err
}

const authServiceDeleteOldSessions = `-- name: AuthServiceDeleteOldSessions :exec
DELETE FROM sessions WHERE created_at <= $1
`

// file: /home/pgbackweb/internal/service/auth/delete_old_sessions.sql
func (q *Queries) AuthServiceDeleteOldSessions(ctx context.Context, dateThreshold time.Time) error {
	_, err := q.db.ExecContext(ctx, authServiceDeleteOldSessions, dateThreshold)
	return err
}

const authServiceDeleteSession = `-- name: AuthServiceDeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

// file: /home/pgbackweb/internal/service/auth/delete_session.sql
func (q *Queries) AuthServiceDeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, authServiceDeleteSession, id)
	return err
}

const authServiceGetUserByToken = `-- name: AuthServiceGetUserByToken :one
SELECT
  users.id, users.name, users.email, users.password, users.created_at, users.updated_at,
  sessions.id as session_id
FROM sessions
JOIN users ON users.id = sessions.user_id
WHERE pgp_sym_decrypt(sessions.token, $1) = $2::TEXT
`

type AuthServiceGetUserByTokenParams struct {
	EncryptionKey string
	Token         string
}

type AuthServiceGetUserByTokenRow struct {
	ID        uuid.UUID
	Name      string
	Email     string
	Password  string
	CreatedAt time.Time
	UpdatedAt sql.NullTime
	SessionID uuid.UUID
}

// file: /home/pgbackweb/internal/service/auth/get_user_by_token.sql
func (q *Queries) AuthServiceGetUserByToken(ctx context.Context, arg AuthServiceGetUserByTokenParams) (AuthServiceGetUserByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, authServiceGetUserByToken, arg.EncryptionKey, arg.Token)
	var i AuthServiceGetUserByTokenRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SessionID,
	)
	return i, err
}

const authServiceGetUserSessions = `-- name: AuthServiceGetUserSessions :many
SELECT id, user_id, token, ip, user_agent, created_at FROM sessions WHERE user_id = $1 ORDER BY created_at DESC
`

// file: /home/pgbackweb/internal/service/auth/get_user_sessions.sql
func (q *Queries) AuthServiceGetUserSessions(ctx context.Context, userID uuid.UUID) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, authServiceGetUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.Ip,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authServiceLoginCreateSession = `-- name: AuthServiceLoginCreateSession :one
INSERT INTO sessions (
  user_id, token, ip, user_agent
) VALUES (
  $1, pgp_sym_encrypt($2::TEXT, $3::TEXT), $4, $5
) RETURNING id, user_id, token, ip, user_agent, created_at, pgp_sym_decrypt(token, $3::TEXT) AS decrypted_token
`

type AuthServiceLoginCreateSessionParams struct {
	UserID        uuid.UUID
	Token         string
	EncryptionKey string
	Ip            string
	UserAgent     string
}

type AuthServiceLoginCreateSessionRow struct {
	ID             uuid.UUID
	UserID         uuid.UUID
	Token          []byte
	Ip             string
	UserAgent      string
	CreatedAt      time.Time
	DecryptedToken string
}

// file: /home/pgbackweb/internal/service/auth/login.sql
func (q *Queries) AuthServiceLoginCreateSession(ctx context.Context, arg AuthServiceLoginCreateSessionParams) (AuthServiceLoginCreateSessionRow, error) {
	row := q.db.QueryRowContext(ctx, authServiceLoginCreateSession,
		arg.UserID,
		arg.Token,
		arg.EncryptionKey,
		arg.Ip,
		arg.UserAgent,
	)
	var i AuthServiceLoginCreateSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Ip,
		&i.UserAgent,
		&i.CreatedAt,
		&i.DecryptedToken,
	)
	return i, err
}

const authServiceLoginGetUserByEmail = `-- name: AuthServiceLoginGetUserByEmail :one
SELECT id, name, email, password, created_at, updated_at FROM users WHERE email = $1
`

// file: /home/pgbackweb/internal/service/auth/login.sql
func (q *Queries) AuthServiceLoginGetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, authServiceLoginGetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const backupsServiceCreateBackup = `-- name: BackupsServiceCreateBackup :one
INSERT INTO backups (
  database_id, destination_id, is_local, name, cron_expression, time_zone,
  is_active, dest_dir, retention_days, all_databases, opt_data_only, opt_schema_only,
  opt_clean, opt_if_exists, opt_create, opt_no_comments, zip_password
)
VALUES (
  $1, $2, $3, $4, $5, $6,
  $7, $8, $9, $10, $11, $12,
  $13, $14, $15, $16,
  CASE
    WHEN NULLIF($17::TEXT, '') IS NULL THEN NULL
    ELSE pgp_sym_encrypt($17::TEXT, $18::TEXT)
  END
)
RETURNING id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password
`

type BackupsServiceCreateBackupParams struct {
	DatabaseID     uuid.UUID
	DestinationID  uuid.NullUUID
	IsLocal        bool
	Name           string
	CronExpression string
	TimeZone       string
	IsActive       bool
	DestDir        string
	RetentionDays  int16
	AllDatabases   bool
	OptDataOnly    bool
	OptSchemaOnly  bool
	OptClean       bool
	OptIfExists    bool
	OptCreate      bool
	OptNoComments  bool
	ZipPassword    string
	EncryptionKey  string
}

// file: /home/pgbackweb/internal/service/backups/create_backup.sql
func (q *Queries) BackupsServiceCreateBackup(ctx context.Context, arg BackupsServiceCreateBackupParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceCreateBackup,
		arg.DatabaseID,
		arg.DestinationID,
		arg.IsLocal,
		arg.Name,
		arg.CronExpression,
		arg.TimeZone,
		arg.IsActive,
		arg.DestDir,
		arg.RetentionDays,
		arg.AllDatabases,
		arg.OptDataOnly,
		arg.OptSchemaOnly,
		arg.OptClean,
		arg.OptIfExists,
		arg.OptCreate,
		arg.OptNoComments,
		arg.ZipPassword,
		arg.EncryptionKey,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.DatabaseID,
		&i.DestinationID,
		&i.Name,
		&i.CronExpression,
		&i.TimeZone,
		&i.IsActive,
		&i.DestDir,
		&i.RetentionDays,
		&i.OptDataOnly,
		&i.OptSchemaOnly,
		&i.OptClean,
		&i.OptIfExists,
		&i.OptCreate,
		&i.OptNoComments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocal,
		&i.AllDatabases,
		&i.ZipPassword,
	)
	return i, err
}

const backupsServiceDeleteBackup = `-- name: BackupsServiceDeleteBackup :exec
DELETE FROM backups
WHERE id = $1
`

// file: /home/pgbackweb/internal/service/backups/delete_backup.sql
func (q *Queries) BackupsServiceDeleteBackup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, backupsServiceDeleteBackup, id)
	return err
}

const backupsServiceDuplicateBackup = `-- name: BackupsServiceDuplicateBackup :one
INSERT INTO backups
SELECT (
  backups
  #= hstore('id', uuid_generate_v4()::text)
  #= hstore('name', (backups.name || ' (copy)')::text)
  #= hstore('is_active', false::text)
  #= hstore('created_at', now()::text)
  #= hstore('updated_at', now()::text)
).*
FROM backups
WHERE backups.id = $1
RETURNING id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password
`

// file: /home/pgbackweb/internal/service/backups/duplicate_backup.sql
func (q *Queries) BackupsServiceDuplicateBackup(ctx context.Context, backupID uuid.UUID) (Backup, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceDuplicateBackup, backupID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.DatabaseID,
		&i.DestinationID,
		&i.Name,
		&i.CronExpression,
		&i.TimeZone,
		&i.IsActive,
		&i.DestDir,
		&i.RetentionDays,
		&i.OptDataOnly,
		&i.OptSchemaOnly,
		&i.OptClean,
		&i.OptIfExists,
		&i.OptCreate,
		&i.OptNoComments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocal,
		&i.AllDatabases,
		&i.ZipPassword,
	)
	return i, err
}

const backupsServiceGetAllBackups = `-- name: BackupsServiceGetAllBackups :many
SELECT id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password FROM backups
ORDER BY created_at DESC
`

// file: /home/pgbackweb/internal/service/backups/get_all_backups.sql
func (q *Queries) BackupsServiceGetAllBackups(ctx context.Context) ([]Backup, error) {
	rows, err := q.db.QueryContext(ctx, backupsServiceGetAllBackups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Backup
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseID,
			&i.DestinationID,
			&i.Name,
			&i.CronExpression,
			&i.TimeZone,
			&i.IsActive,
			&i.DestDir,
			&i.RetentionDays,
			&i.OptDataOnly,
			&i.OptSchemaOnly,
			&i.OptClean,
			&i.OptIfExists,
			&i.OptCreate,
			&i.OptNoComments,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsLocal,
			&i.AllDatabases,
			&i.ZipPassword,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const backupsServiceGetBackup = `-- name: BackupsServiceGetBackup :one
SELECT id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password FROM backups
WHERE id = $1
`

// file: /home/pgbackweb/internal/service/backups/get_backup.sql
func (q *Queries) BackupsServiceGetBackup(ctx context.Context, id uuid.UUID) (Backup, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceGetBackup, id)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.DatabaseID,
		&i.DestinationID,
		&i.Name,
		&i.CronExpression,
		&i.TimeZone,
		&i.IsActive,
		&i.DestDir,
		&i.RetentionDays,
		&i.OptDataOnly,
		&i.OptSchemaOnly,
		&i.OptClean,
		&i.OptIfExists,
		&i.OptCreate,
		&i.OptNoComments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocal,
		&i.AllDatabases,
		&i.ZipPassword,
	)
	return i, err
}

const backupsServiceGetBackupsQty = `-- name: BackupsServiceGetBackupsQty :one
SELECT 
  COUNT(*) AS all,
  COALESCE(SUM(CASE WHEN is_active = true THEN 1 ELSE 0 END), 0)::INTEGER AS active,
  COALESCE(SUM(CASE WHEN is_active = false THEN 1 ELSE 0 END), 0)::INTEGER AS inactive
FROM backups
`

type BackupsServiceGetBackupsQtyRow struct {
	All      int64
	Active   int32
	Inactive int32
}

// file: /home/pgbackweb/internal/service/backups/get_backups_qty.sql
func (q *Queries) BackupsServiceGetBackupsQty(ctx context.Context) (BackupsServiceGetBackupsQtyRow, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceGetBackupsQty)
	var i BackupsServiceGetBackupsQtyRow
	err := row.Scan(&i.All, &i.Active, &i.Inactive)
	return i, err
}

const backupsServiceGetScheduleAllData = `-- name: BackupsServiceGetScheduleAllData :many
SELECT 
  id,
  is_active,
  cron_expression,
  time_zone
FROM backups
ORDER BY created_at DESC
`

type BackupsServiceGetScheduleAllDataRow struct {
	ID             uuid.UUID
	IsActive       bool
	CronExpression string
	TimeZone       string
}

// file: /home/pgbackweb/internal/service/backups/schedule_all.sql
func (q *Queries) BackupsServiceGetScheduleAllData(ctx context.Context) ([]BackupsServiceGetScheduleAllDataRow, error) {
	rows, err := q.db.QueryContext(ctx, backupsServiceGetScheduleAllData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupsServiceGetScheduleAllDataRow
	for rows.Next() {
		var i BackupsServiceGetScheduleAllDataRow
		if err := rows.Scan(
			&i.ID,
			&i.IsActive,
			&i.CronExpression,
			&i.TimeZone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const backupsServicePaginateBackups = `-- name: BackupsServicePaginateBackups :many
SELECT
  backups.id, backups.database_id, backups.destination_id, backups.name, backups.cron_expression, backups.time_zone, backups.is_active, backups.dest_dir, backups.retention_days, backups.opt_data_only, backups.opt_schema_only, backups.opt_clean, backups.opt_if_exists, backups.opt_create, backups.opt_no_comments, backups.created_at, backups.updated_at, backups.is_local, backups.all_databases, backups.zip_password,
  databases.name AS database_name,
  destinations.name AS destination_name
FROM backups
INNER JOIN databases ON backups.database_id = databases.id
LEFT JOIN destinations ON backups.destination_id = destinations.id
ORDER BY backups.created_at DESC
LIMIT $2 OFFSET $1
`

type BackupsServicePaginateBackupsParams struct {
	Offset int32
	Limit  int32
}

type BackupsServicePaginateBackupsRow struct {
	ID              uuid.UUID
	DatabaseID      uuid.UUID
	DestinationID   uuid.NullUUID
	Name            string
	CronExpression  string
	TimeZone        string
	IsActive        bool
	DestDir         string
	RetentionDays   int16
	OptDataOnly     bool
	OptSchemaOnly   bool
	OptClean        bool
	OptIfExists     bool
	OptCreate       bool
	OptNoComments   bool
	CreatedAt       time.Time
	UpdatedAt       sql.NullTime
	IsLocal         bool
	AllDatabases    bool
	ZipPassword     []byte
	DatabaseName    string
	DestinationName sql.NullString
}

// file: /home/pgbackweb/internal/service/backups/paginate_backups.sql
func (q *Queries) BackupsServicePaginateBackups(ctx context.Context, arg BackupsServicePaginateBackupsParams) ([]BackupsServicePaginateBackupsRow, error) {
	rows, err := q.db.QueryContext(ctx, backupsServicePaginateBackups, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupsServicePaginateBackupsRow
	for rows.Next() {
		var i BackupsServicePaginateBackupsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseID,
			&i.DestinationID,
			&i.Name,
			&i.CronExpression,
			&i.TimeZone,
			&i.IsActive,
			&i.DestDir,
			&i.RetentionDays,
			&i.OptDataOnly,
			&i.OptSchemaOnly,
			&i.OptClean,
			&i.OptIfExists,
			&i.OptCreate,
			&i.OptNoComments,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsLocal,
			&i.AllDatabases,
			&i.ZipPassword,
			&i.DatabaseName,
			&i.DestinationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const backupsServicePaginateBackupsCount = `-- name: BackupsServicePaginateBackupsCount :one
SELECT COUNT(*) FROM backups
`

// file: /home/pgbackweb/internal/service/backups/paginate_backups.sql
func (q *Queries) BackupsServicePaginateBackupsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, backupsServicePaginateBackupsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const backupsServiceToggleIsActive = `-- name: BackupsServiceToggleIsActive :one
UPDATE backups
SET is_active = NOT is_active
WHERE id = $1
RETURNING id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password
`

// file: /home/pgbackweb/internal/service/backups/toggle_is_active.sql
func (q *Queries) BackupsServiceToggleIsActive(ctx context.Context, backupID uuid.UUID) (Backup, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceToggleIsActive, backupID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.DatabaseID,
		&i.DestinationID,
		&i.Name,
		&i.CronExpression,
		&i.TimeZone,
		&i.IsActive,
		&i.DestDir,
		&i.RetentionDays,
		&i.OptDataOnly,
		&i.OptSchemaOnly,
		&i.OptClean,
		&i.OptIfExists,
		&i.OptCreate,
		&i.OptNoComments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocal,
		&i.AllDatabases,
		&i.ZipPassword,
	)
	return i, err
}

const backupsServiceUpdateBackup = `-- name: BackupsServiceUpdateBackup :one
UPDATE backups
SET
  database_id = COALESCE($1, database_id),
  destination_id = COALESCE($2, destination_id),
  is_local = COALESCE($3, is_local),
  name = COALESCE($4, $4),
  cron_expression = COALESCE($5, cron_expression),
  time_zone = COALESCE($6, time_zone),
  is_active = COALESCE($7, is_active),
  dest_dir = COALESCE($8, dest_dir),
  retention_days = COALESCE($9, retention_days),
  all_databases = COALESCE($10, all_databases),
  opt_data_only = COALESCE($11, opt_data_only),
  opt_schema_only = COALESCE($12, opt_schema_only),
  opt_clean = COALESCE($13, opt_clean),
  opt_if_exists = COALESCE($14, opt_if_exists),
  opt_create = COALESCE($15, opt_create),
  opt_no_comments = COALESCE($16, opt_no_comments),
  zip_password = CASE
    WHEN $17::TEXT IS NULL THEN zip_password
    WHEN $17::TEXT = '' THEN NULL
    ELSE pgp_sym_encrypt($17::TEXT, $18::TEXT)
  END
WHERE id = $19
RETURNING id, database_id, destination_id, name, cron_expression, time_zone, is_active, dest_dir, retention_days, opt_data_only, opt_schema_only, opt_clean, opt_if_exists, opt_create, opt_no_comments, created_at, updated_at, is_local, all_databases, zip_password
`

type BackupsServiceUpdateBackupParams struct {
	DatabaseID     uuid.NullUUID
	DestinationID  uuid.NullUUID
	IsLocal        sql.NullBool
	Name           sql.NullString
	CronExpression sql.NullString
	TimeZone       sql.NullString
	IsActive       sql.NullBool
	DestDir        sql.NullString
	RetentionDays  sql.NullInt16
	AllDatabases   sql.NullBool
	OptDataOnly    sql.NullBool
	OptSchemaOnly  sql.NullBool
	OptClean       sql.NullBool
	OptIfExists    sql.NullBool
	OptCreate      sql.NullBool
	OptNoComments  sql.NullBool
	ZipPassword    sql.NullString
	EncryptionKey  string
	ID             uuid.UUID
}

// file: /home/pgbackweb/internal/service/backups/update_backup.sql
func (q *Queries) BackupsServiceUpdateBackup(ctx context.Context, arg BackupsServiceUpdateBackupParams) (Backup, error) {
	row := q.db.QueryRowContext(ctx, backupsServiceUpdateBackup,
		arg.DatabaseID,
		arg.DestinationID,
		arg.IsLocal,
		arg.Name,
		arg.CronExpression,
		arg.TimeZone,
		arg.IsActive,
		arg.DestDir,
		arg.RetentionDays,
		arg.AllDatabases,
		arg.OptDataOnly,
		arg.OptSchemaOnly,
		arg.OptClean,
		arg.OptIfExists,
		arg.OptCreate,
		arg.OptNoComments,
		arg.ZipPassword,
		arg.EncryptionKey,
		arg.ID,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.DatabaseID,
		&i.DestinationID,
		&i.Name,
		&i.CronExpression,
		&i.TimeZone,
		&i.IsActive,
		&i.DestDir,
		&i.RetentionDays,
		&i.OptDataOnly,
		&i.OptSchemaOnly,
		&i.OptClean,
		&i.OptIfExists,
		&i.OptCreate,
		&i.OptNoComments,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLocal,
		&i.AllDatabases,
		&i.ZipPassword,
	)
	return i, err
}

const databasesServiceCreateDatabase = `-- name: DatabasesServiceCreateDatabase :one
INSERT INTO databases (
  name, connection_string, pg_version
)
VALUES (
  $1, pgp_sym_encrypt($2, $3), $4
)
RETURNING id, name, connection_string, pg_version, created_at, updated_at, test_ok, test_error, last_test_at
`

type DatabasesServiceCreateDatabaseParams struct {
	Name             string
	ConnectionString string
	EncryptionKey    string
	PgVersion        string
}

// file: /home/pgbackweb/internal/service/databases/create_database.sql
func (q *Queries) DatabasesServiceCreateDatabase(ctx context.Context, arg DatabasesServiceCreateDatabaseParams) (Database, error) {
	row := q.db.QueryRowContext(ctx, databasesServiceCreateDatabase,
		arg.Name,
		arg.ConnectionString,
		arg.EncryptionKey,
		arg.PgVersion,
	)
	var i Database
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ConnectionString,
		&i.PgVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
	)
	return i, err
}

const databasesServiceDeleteDatabase = `-- name: DatabasesServiceDeleteDatabase :exec
DELETE FROM databases
WHERE id = $1
`

// file: /home/pgbackweb/internal/service/databases/delete_database.sql
func (q *Queries) DatabasesServiceDeleteDatabase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, databasesServiceDeleteDatabase, id)
	return err
}

const databasesServiceGetAllDatabases = `-- name: DatabasesServiceGetAllDatabases :many
SELECT
  id, name, connection_string, pg_version, created_at, updated_at, test_ok, test_error, last_test_at,
  pgp_sym_decrypt(connection_string, $1) AS decrypted_connection_string
FROM databases
ORDER BY created_at DESC
`

type DatabasesServiceGetAllDatabasesRow struct {
	ID                        uuid.UUID
	Name                      string
	ConnectionString          []byte
	PgVersion                 string
	CreatedAt                 time.Time
	UpdatedAt                 sql.NullTime
	TestOk                    sql.NullBool
	TestError                 sql.NullString
	LastTestAt                sql.NullTime
	DecryptedConnectionString string
}

// file: /home/pgbackweb/internal/service/databases/get_all_databases.sql
func (q *Queries) DatabasesServiceGetAllDatabases(ctx context.Context, encryptionKey string) ([]DatabasesServiceGetAllDatabasesRow, error) {
	rows, err := q.db.QueryContext(ctx, databasesServiceGetAllDatabases, encryptionKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatabasesServiceGetAllDatabasesRow
	for rows.Next() {
		var i DatabasesServiceGetAllDatabasesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ConnectionString,
			&i.PgVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestOk,
			&i.TestError,
			&i.LastTestAt,
			&i.DecryptedConnectionString,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const databasesServiceGetDatabase = `-- name: DatabasesServiceGetDatabase :one
SELECT
  id, name, connection_string, pg_version, created_at, updated_at, test_ok, test_error, last_test_at,
  pgp_sym_decrypt(connection_string, $1) AS decrypted_connection_string
FROM databases
WHERE id = $2
`

type DatabasesServiceGetDatabaseParams struct {
	EncryptionKey string
	ID            uuid.UUID
}

type DatabasesServiceGetDatabaseRow struct {
	ID                        uuid.UUID
	Name                      string
	ConnectionString          []byte
	PgVersion                 string
	CreatedAt                 time.Time
	UpdatedAt                 sql.NullTime
	TestOk                    sql.NullBool
	TestError                 sql.NullString
	LastTestAt                sql.NullTime
	DecryptedConnectionString string
}

// file: /home/pgbackweb/internal/service/databases/get_database.sql
func (q *Queries) DatabasesServiceGetDatabase(ctx context.Context, arg DatabasesServiceGetDatabaseParams) (DatabasesServiceGetDatabaseRow, error) {
	row := q.db.QueryRowContext(ctx, databasesServiceGetDatabase, arg.EncryptionKey, arg.ID)
	var i DatabasesServiceGetDatabaseRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ConnectionString,
		&i.PgVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
		&i.DecryptedConnectionString,
	)
	return i, err
}

const databasesServiceGetDatabasesQty = `-- name: DatabasesServiceGetDatabasesQty :one
SELECT 
  COUNT(*) AS all,
  COALESCE(SUM(CASE WHEN test_ok = true THEN 1 ELSE 0 END), 0)::INTEGER AS healthy,
  COALESCE(SUM(CASE WHEN test_ok = false THEN 1 ELSE 0 END), 0)::INTEGER AS unhealthy
FROM databases
`

type DatabasesServiceGetDatabasesQtyRow struct {
	All       int64
	Healthy   int32
	Unhealthy int32
}

// file: /home/pgbackweb/internal/service/databases/get_databases_qty.sql
func (q *Queries) DatabasesServiceGetDatabasesQty(ctx context.Context) (DatabasesServiceGetDatabasesQtyRow, error) {
	row := q.db.QueryRowContext(ctx, databasesServiceGetDatabasesQty)
	var i DatabasesServiceGetDatabasesQtyRow
	err := row.Scan(&i.All, &i.Healthy, &i.Unhealthy)
	return i, err
}

const databasesServicePaginateDatabases = `-- name: DatabasesServicePaginateDatabases :many
SELECT
  id, name, connection_string, pg_version, created_at, updated_at, test_ok, test_error, last_test_at,
  pgp_sym_decrypt(connection_string, $1) AS decrypted_connection_string
FROM databases
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type DatabasesServicePaginateDatabasesParams struct {
	EncryptionKey string
	Offset        int32
	Limit         int32
}

type DatabasesServicePaginateDatabasesRow struct {
	ID                        uuid.UUID
	Name                      string
	ConnectionString          []byte
	PgVersion                 string
	CreatedAt                 time.Time
	UpdatedAt                 sql.NullTime
	TestOk                    sql.NullBool
	TestError                 sql.NullString
	LastTestAt                sql.NullTime
	DecryptedConnectionString string
}

// file: /home/pgbackweb/internal/service/databases/paginate_databases.sql
func (q *Queries) DatabasesServicePaginateDatabases(ctx context.Context, arg DatabasesServicePaginateDatabasesParams) ([]DatabasesServicePaginateDatabasesRow, error) {
	rows, err := q.db.QueryContext(ctx, databasesServicePaginateDatabases, arg.EncryptionKey, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatabasesServicePaginateDatabasesRow
	for rows.Next() {
		var i DatabasesServicePaginateDatabasesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ConnectionString,
			&i.PgVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestOk,
			&i.TestError,
			&i.LastTestAt,
			&i.DecryptedConnectionString,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const databasesServicePaginateDatabasesCount = `-- name: DatabasesServicePaginateDatabasesCount :one
SELECT COUNT(*) FROM databases
`

// file: /home/pgbackweb/internal/service/databases/paginate_databases.sql
func (q *Queries) DatabasesServicePaginateDatabasesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, databasesServicePaginateDatabasesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const databasesServiceSetTestData = `-- name: DatabasesServiceSetTestData :exec
UPDATE databases
SET test_ok = $1,
    test_error = $2,
    last_test_at = NOW()
WHERE id = $3
`

type DatabasesServiceSetTestDataParams struct {
	TestOk     sql.NullBool
	TestError  sql.NullString
	DatabaseID uuid.UUID
}

// file: /home/pgbackweb/internal/service/databases/test_database.sql
func (q *Queries) DatabasesServiceSetTestData(ctx context.Context, arg DatabasesServiceSetTestDataParams) error {
	_, err := q.db.ExecContext(ctx, databasesServiceSetTestData, arg.TestOk, arg.TestError, arg.DatabaseID)
	return err
}

const databasesServiceUpdateDatabase = `-- name: DatabasesServiceUpdateDatabase :one
UPDATE databases
SET
  name = COALESCE($1, name),
  pg_version = COALESCE($2, pg_version),
  connection_string = CASE
    WHEN $3::TEXT IS NOT NULL
    THEN pgp_sym_encrypt(
      $3::TEXT, $4::TEXT
    )
    ELSE connection_string
  END
WHERE id = $5
RETURNING id, name, connection_string, pg_version, created_at, updated_at, test_ok, test_error, last_test_at
`

type DatabasesServiceUpdateDatabaseParams struct {
	Name             sql.NullString
	PgVersion        sql.NullString
	ConnectionString sql.NullString
	EncryptionKey    string
	ID               uuid.UUID
}

// file: /home/pgbackweb/internal/service/databases/update_database.sql
func (q *Queries) DatabasesServiceUpdateDatabase(ctx context.Context, arg DatabasesServiceUpdateDatabaseParams) (Database, error) {
	row := q.db.QueryRowContext(ctx, databasesServiceUpdateDatabase,
		arg.Name,
		arg.PgVersion,
		arg.ConnectionString,
		arg.EncryptionKey,
		arg.ID,
	)
	var i Database
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ConnectionString,
		&i.PgVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
	)
	return i, err
}

const destinationsServiceCreateDestination = `-- name: DestinationsServiceCreateDestination :one
INSERT INTO destinations (
  name, bucket_name, region, endpoint,
  access_key, secret_key, force_path_style
)
VALUES (
  $1, $2, $3, $4,
  pgp_sym_encrypt($5, $6),
  pgp_sym_encrypt($7, $6), $8
)
RETURNING id, name, bucket_name, access_key, secret_key, region, endpoint, created_at, updated_at, test_ok, test_error, last_test_at, force_path_style
`

type DestinationsServiceCreateDestinationParams struct {
	Name           string
	BucketName     string
	Region         string
	Endpoint       string
	AccessKey      string
	EncryptionKey  string
	SecretKey      string
	ForcePathStyle bool
}

// file: /home/pgbackweb/internal/service/destinations/create_destination.sql
func (q *Queries) DestinationsServiceCreateDestination(ctx context.Context, arg DestinationsServiceCreateDestinationParams) (Destination, error) {
	row := q.db.QueryRowContext(ctx, destinationsServiceCreateDestination,
		arg.Name,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.AccessKey,
		arg.EncryptionKey,
		arg.SecretKey,
		arg.ForcePathStyle,
	)
	var i Destination
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.AccessKey,
		&i.SecretKey,
		&i.Region,
		&i.Endpoint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
		&i.ForcePathStyle,
	)
	return i, err
}

const destinationsServiceDeleteDestination = `-- name: DestinationsServiceDeleteDestination :exec
DELETE FROM destinations
WHERE id = $1
`

// file: /home/pgbackweb/internal/service/destinations/delete_destination.sql
func (q *Queries) DestinationsServiceDeleteDestination(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, destinationsServiceDeleteDestination, id)
	return err
}

const destinationsServiceGetAllDestinations = `-- name: DestinationsServiceGetAllDestinations :many
SELECT
  id, name, bucket_name, access_key, secret_key, region, endpoint, created_at, updated_at, test_ok, test_error, last_test_at, force_path_style,
  pgp_sym_decrypt(access_key, $1) AS decrypted_access_key,
  pgp_sym_decrypt(secret_key, $1) AS decrypted_secret_key
FROM destinations
ORDER BY created_at DESC
`

type DestinationsServiceGetAllDestinationsRow struct {
	ID                 uuid.UUID
	Name               string
	BucketName         string
	AccessKey          []byte
	SecretKey          []byte
	Region             string
	Endpoint           string
	CreatedAt          time.Time
	UpdatedAt          sql.NullTime
	TestOk             sql.NullBool
	TestError          sql.NullString
	LastTestAt         sql.NullTime
	ForcePathStyle     bool
	DecryptedAccessKey string
	DecryptedSecretKey string
}

// file: /home/pgbackweb/internal/service/destinations/get_all_destinations.sql
func (q *Queries) DestinationsServiceGetAllDestinations(ctx context.Context, encryptionKey string) ([]DestinationsServiceGetAllDestinationsRow, error) {
	rows, err := q.db.QueryContext(ctx, destinationsServiceGetAllDestinations, encryptionKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DestinationsServiceGetAllDestinationsRow
	for rows.Next() {
		var i DestinationsServiceGetAllDestinationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BucketName,
			&i.AccessKey,
			&i.SecretKey,
			&i.Region,
			&i.Endpoint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestOk,
			&i.TestError,
			&i.LastTestAt,
			&i.ForcePathStyle,
			&i.DecryptedAccessKey,
			&i.DecryptedSecretKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const destinationsServiceGetDestination = `-- name: DestinationsServiceGetDestination :one
SELECT
  id, name, bucket_name, access_key, secret_key, region, endpoint, created_at, updated_at, test_ok, test_error, last_test_at, force_path_style,
  pgp_sym_decrypt(access_key, $1) AS decrypted_access_key,
  pgp_sym_decrypt(secret_key, $1) AS decrypted_secret_key
FROM destinations
WHERE id = $2
`

type DestinationsServiceGetDestinationParams struct {
	EncryptionKey string
	ID            uuid.UUID
}

type DestinationsServiceGetDestinationRow struct {
	ID                 uuid.UUID
	Name               string
	BucketName         string
	AccessKey          []byte
	SecretKey          []byte
	Region             string
	Endpoint           string
	CreatedAt          time.Time
	UpdatedAt          sql.NullTime
	TestOk             sql.NullBool
	TestError          sql.NullString
	LastTestAt         sql.NullTime
	ForcePathStyle     bool
	DecryptedAccessKey string
	DecryptedSecretKey string
}

// file: /home/pgbackweb/internal/service/destinations/get_destination.sql
func (q *Queries) DestinationsServiceGetDestination(ctx context.Context, arg DestinationsServiceGetDestinationParams) (DestinationsServiceGetDestinationRow, error) {
	row := q.db.QueryRowContext(ctx, destinationsServiceGetDestination, arg.EncryptionKey, arg.ID)
	var i DestinationsServiceGetDestinationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.AccessKey,
		&i.SecretKey,
		&i.Region,
		&i.Endpoint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
		&i.ForcePathStyle,
		&i.DecryptedAccessKey,
		&i.DecryptedSecretKey,
	)
	return i, err
}

const destinationsServiceGetDestinationsQty = `-- name: DestinationsServiceGetDestinationsQty :one
SELECT 
  COUNT(*) AS all,
  COALESCE(SUM(CASE WHEN test_ok = true THEN 1 ELSE 0 END), 0)::INTEGER AS healthy,
  COALESCE(SUM(CASE WHEN test_ok = false THEN 1 ELSE 0 END), 0)::INTEGER AS unhealthy
FROM destinations
`

type DestinationsServiceGetDestinationsQtyRow struct {
	All       int64
	Healthy   int32
	Unhealthy int32
}

// file: /home/pgbackweb/internal/service/destinations/get_destinations_qty.sql
func (q *Queries) DestinationsServiceGetDestinationsQty(ctx context.Context) (DestinationsServiceGetDestinationsQtyRow, error) {
	row := q.db.QueryRowContext(ctx, destinationsServiceGetDestinationsQty)
	var i DestinationsServiceGetDestinationsQtyRow
	err := row.Scan(&i.All, &i.Healthy, &i.Unhealthy)
	return i, err
}

const destinationsServicePaginateDestinations = `-- name: DestinationsServicePaginateDestinations :many
SELECT
  id, name, bucket_name, access_key, secret_key, region, endpoint, created_at, updated_at, test_ok, test_error, last_test_at, force_path_style,
  pgp_sym_decrypt(access_key, $1) AS decrypted_access_key,
  pgp_sym_decrypt(secret_key, $1) AS decrypted_secret_key
FROM destinations
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type DestinationsServicePaginateDestinationsParams struct {
	EncryptionKey string
	Offset        int32
	Limit         int32
}

type DestinationsServicePaginateDestinationsRow struct {
	ID                 uuid.UUID
	Name               string
	BucketName         string
	AccessKey          []byte
	SecretKey          []byte
	Region             string
	Endpoint           string
	CreatedAt          time.Time
	UpdatedAt          sql.NullTime
	TestOk             sql.NullBool
	TestError          sql.NullString
	LastTestAt         sql.NullTime
	ForcePathStyle     bool
	DecryptedAccessKey string
	DecryptedSecretKey string
}

// file: /home/pgbackweb/internal/service/destinations/paginate_destinations.sql
func (q *Queries) DestinationsServicePaginateDestinations(ctx context.Context, arg DestinationsServicePaginateDestinationsParams) ([]DestinationsServicePaginateDestinationsRow, error) {
	rows, err := q.db.QueryContext(ctx, destinationsServicePaginateDestinations, arg.EncryptionKey, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DestinationsServicePaginateDestinationsRow
	for rows.Next() {
		var i DestinationsServicePaginateDestinationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BucketName,
			&i.AccessKey,
			&i.SecretKey,
			&i.Region,
			&i.Endpoint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestOk,
			&i.TestError,
			&i.LastTestAt,
			&i.ForcePathStyle,
			&i.DecryptedAccessKey,
			&i.DecryptedSecretKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const destinationsServicePaginateDestinationsCount = `-- name: DestinationsServicePaginateDestinationsCount :one
SELECT COUNT(*) FROM destinations
`

// file: /home/pgbackweb/internal/service/destinations/paginate_destinations.sql
func (q *Queries) DestinationsServicePaginateDestinationsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, destinationsServicePaginateDestinationsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const destinationsServiceSetTestData = `-- name: DestinationsServiceSetTestData :exec
UPDATE destinations
SET test_ok = $1,
    test_error = $2,
    last_test_at = NOW()
WHERE id = $3
`

type DestinationsServiceSetTestDataParams struct {
	TestOk        sql.NullBool
	TestError     sql.NullString
	DestinationID uuid.UUID
}

// file: /home/pgbackweb/internal/service/destinations/test_destination.sql
func (q *Queries) DestinationsServiceSetTestData(ctx context.Context, arg DestinationsServiceSetTestDataParams) error {
	_, err := q.db.ExecContext(ctx, destinationsServiceSetTestData, arg.TestOk, arg.TestError, arg.DestinationID)
	return err
}

const destinationsServiceUpdateDestination = `-- name: DestinationsServiceUpdateDestination :one
UPDATE destinations
SET
  name = COALESCE($1, name),
  bucket_name = COALESCE($2, bucket_name),
  region = COALESCE($3, region),
  endpoint = COALESCE($4, endpoint),
  force_path_style = COALESCE($5, force_path_style),
  access_key = CASE
    WHEN $6::TEXT IS NOT NULL
    THEN pgp_sym_encrypt($6::TEXT, $7::TEXT)
    ELSE access_key
  END,
  secret_key = CASE
    WHEN $8::TEXT IS NOT NULL
    THEN pgp_sym_encrypt($8::TEXT, $7::TEXT)
    ELSE secret_key
  END
WHERE id = $9
RETURNING id, name, bucket_name, access_key, secret_key, region, endpoint, created_at, updated_at, test_ok, test_error, last_test_at, force_path_style
`

type DestinationsServiceUpdateDestinationParams struct {
	Name           sql.NullString
	BucketName     sql.NullString
	Region         sql.NullString
	Endpoint       sql.NullString
	ForcePathStyle sql.NullBool
	AccessKey      sql.NullString
	EncryptionKey  string
	SecretKey      sql.NullString
	ID             uuid.UUID
}

// file: /home/pgbackweb/internal/service/destinations/update_destination.sql
func (q *Queries) DestinationsServiceUpdateDestination(ctx context.Context, arg DestinationsServiceUpdateDestinationParams) (Destination, error) {
	row := q.db.QueryRowContext(ctx, destinationsServiceUpdateDestination,
		arg.Name,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.ForcePathStyle,
		arg.AccessKey,
		arg.EncryptionKey,
		arg.SecretKey,
		arg.ID,
	)
	var i Destination
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.AccessKey,
		&i.SecretKey,
		&i.Region,
		&i.Endpoint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TestOk,
		&i.TestError,
		&i.LastTestAt,
		&i.ForcePathStyle,
	)
	return i, err
}

const executionsServiceCreateExecution = `-- name: ExecutionsServiceCreateExecution :one
INSERT INTO executions (backup_id, status, message, path)
VALUES ($1, $2, $3, $4)
RETURNING id, backup_id, status, message, path, started_at, updated_at, finished_at, deleted_at, file_size
`

type ExecutionsServiceCreateExecutionParams struct {
	BackupID uuid.UUID
	Status   string
	Message  sql.NullString
	Path     sql.NullString
}

// file: /home/pgbackweb/internal/service/executions/create_execution.sql
func (q *Queries) ExecutionsServiceCreateExecution(ctx context.Context, arg ExecutionsServiceCreateExecutionParams) (Execution, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceCreateExecution,
		arg.BackupID,
		arg.Status,
		arg.Message,
		arg.Path,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.BackupID,
		&i.Status,
		&i.Message,
		&i.Path,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.DeletedAt,
		&i.FileSize,
	)
	return i, err
}

const executionsServiceGetBackupData = `-- name: ExecutionsServiceGetBackupData :one
SELECT
  backups.is_active as backup_is_active,
  backups.is_local as backup_is_local,
  backups.dest_dir as backup_dest_dir,
  backups.all_databases as backup_all_databases,
  backups.opt_data_only as backup_opt_data_only,
  backups.opt_schema_only as backup_opt_schema_only,
  backups.opt_clean as backup_opt_clean,
  backups.opt_if_exists as backup_opt_if_exists,
  backups.opt_create as backup_opt_create,	
  backups.opt_no_comments as backup_opt_no_comments,
  (
    CASE WHEN backups.zip_password IS NOT NULL
    THEN pgp_sym_decrypt(backups.zip_password, $1)
    ELSE ''
    END
  ) AS decrypted_backup_zip_password,

  pgp_sym_decrypt(databases.connection_string, $1) AS decrypted_database_connection_string,
  databases.pg_version as database_pg_version,

  destinations.bucket_name as destination_bucket_name,
  destinations.region as destination_region,
  destinations.endpoint as destination_endpoint,
  destinations.force_path_style as destination_force_path_style,
  (
    CASE WHEN destinations.access_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.access_key, $1)
    ELSE ''
    END
  ) AS decrypted_destination_access_key,
  (
    CASE WHEN destinations.secret_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.secret_key, $1)
    ELSE ''
    END
  ) AS decrypted_destination_secret_key
FROM backups
INNER JOIN databases ON backups.database_id = databases.id
LEFT JOIN destinations ON backups.destination_id = destinations.id
WHERE backups.id = $2
`

type ExecutionsServiceGetBackupDataParams struct {
	EncryptionKey string
	BackupID      uuid.UUID
}

type ExecutionsServiceGetBackupDataRow struct {
	BackupIsActive                    bool
	BackupIsLocal                     bool
	BackupDestDir                     string
	BackupAllDatabases                bool
	BackupOptDataOnly                 bool
	BackupOptSchemaOnly               bool
	BackupOptClean                    bool
	BackupOptIfExists                 bool
	BackupOptCreate                   bool
	BackupOptNoComments               bool
	DecryptedBackupZipPassword        string
	DecryptedDatabaseConnectionString string
	DatabasePgVersion                 string
	DestinationBucketName             sql.NullString
	DestinationRegion                 sql.NullString
	DestinationEndpoint               sql.NullString
	DestinationForcePathStyle         sql.NullBool
	DecryptedDestinationAccessKey     string
	DecryptedDestinationSecretKey     string
}

// file: /home/pgbackweb/internal/service/executions/run_execution.sql
func (q *Queries) ExecutionsServiceGetBackupData(ctx context.Context, arg ExecutionsServiceGetBackupDataParams) (ExecutionsServiceGetBackupDataRow, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceGetBackupData, arg.EncryptionKey, arg.BackupID)
	var i ExecutionsServiceGetBackupDataRow
	err := row.Scan(
		&i.BackupIsActive,
		&i.BackupIsLocal,
		&i.BackupDestDir,
		&i.BackupAllDatabases,
		&i.BackupOptDataOnly,
		&i.BackupOptSchemaOnly,
		&i.BackupOptClean,
		&i.BackupOptIfExists,
		&i.BackupOptCreate,
		&i.BackupOptNoComments,
		&i.DecryptedBackupZipPassword,
		&i.DecryptedDatabaseConnectionString,
		&i.DatabasePgVersion,
		&i.DestinationBucketName,
		&i.DestinationRegion,
		&i.DestinationEndpoint,
		&i.DestinationForcePathStyle,
		&i.DecryptedDestinationAccessKey,
		&i.DecryptedDestinationSecretKey,
	)
	return i, err
}

const executionsServiceGetDownloadLinkOrPathData = `-- name: ExecutionsServiceGetDownloadLinkOrPathData :one
SELECT
  executions.path AS path,
  backups.is_local AS is_local,
  destinations.bucket_name AS bucket_name,
  destinations.region AS region,
  destinations.endpoint AS endpoint,
  destinations.endpoint as destination_endpoint,
  destinations.force_path_style AS force_path_style,
  (
    CASE WHEN destinations.access_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.access_key, $1::TEXT)
    ELSE ''
    END
  ) AS decrypted_access_key,
  (
    CASE WHEN destinations.secret_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.secret_key, $1::TEXT)
    ELSE ''
    END
  ) AS decrypted_secret_key
FROM executions
INNER JOIN backups ON backups.id = executions.backup_id
LEFT JOIN destinations ON destinations.id = backups.destination_id
WHERE executions.id = $2
`

type ExecutionsServiceGetDownloadLinkOrPathDataParams struct {
	DecryptionKey string
	ExecutionID   uuid.UUID
}

type ExecutionsServiceGetDownloadLinkOrPathDataRow struct {
	Path                sql.NullString
	IsLocal             bool
	BucketName          sql.NullString
	Region              sql.NullString
	Endpoint            sql.NullString
	DestinationEndpoint sql.NullString
	ForcePathStyle      sql.NullBool
	DecryptedAccessKey  string
	DecryptedSecretKey  string
}

// file: /home/pgbackweb/internal/service/executions/get_execution_download_link_or_path.sql
func (q *Queries) ExecutionsServiceGetDownloadLinkOrPathData(ctx context.Context, arg ExecutionsServiceGetDownloadLinkOrPathDataParams) (ExecutionsServiceGetDownloadLinkOrPathDataRow, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceGetDownloadLinkOrPathData, arg.DecryptionKey, arg.ExecutionID)
	var i ExecutionsServiceGetDownloadLinkOrPathDataRow
	err := row.Scan(
		&i.Path,
		&i.IsLocal,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.DestinationEndpoint,
		&i.ForcePathStyle,
		&i.DecryptedAccessKey,
		&i.DecryptedSecretKey,
	)
	return i, err
}

const executionsServiceGetExecution = `-- name: ExecutionsServiceGetExecution :one
SELECT
  executions.id, executions.backup_id, executions.status, executions.message, executions.path, executions.started_at, executions.updated_at, executions.finished_at, executions.deleted_at, executions.file_size,
  databases.id AS database_id,
  databases.pg_version AS database_pg_version
FROM executions
INNER JOIN backups ON backups.id = executions.backup_id
INNER JOIN databases ON databases.id = backups.database_id
WHERE executions.id = $1
`

type ExecutionsServiceGetExecutionRow struct {
	ID                uuid.UUID
	BackupID          uuid.UUID
	Status            string
	Message           sql.NullString
	Path              sql.NullString
	StartedAt         time.Time
	UpdatedAt         sql.NullTime
	FinishedAt        sql.NullTime
	DeletedAt         sql.NullTime
	FileSize          sql.NullInt64
	DatabaseID        uuid.UUID
	DatabasePgVersion string
}

// file: /home/pgbackweb/internal/service/executions/get_execution.sql
func (q *Queries) ExecutionsServiceGetExecution(ctx context.Context, id uuid.UUID) (ExecutionsServiceGetExecutionRow, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceGetExecution, id)
	var i ExecutionsServiceGetExecutionRow
	err := row.Scan(
		&i.ID,
		&i.BackupID,
		&i.Status,
		&i.Message,
		&i.Path,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.DeletedAt,
		&i.FileSize,
		&i.DatabaseID,
		&i.DatabasePgVersion,
	)
	return i, err
}

const executionsServiceGetExecutionForSoftDelete = `-- name: ExecutionsServiceGetExecutionForSoftDelete :one
SELECT
  executions.id as execution_id,
  executions.path as execution_path,

  backups.id as backup_id,
  backups.is_local as backup_is_local,

  destinations.bucket_name as destination_bucket_name,
  destinations.region as destination_region,
  destinations.endpoint as destination_endpoint,
  destinations.force_path_style as destination_force_path_style,
  (
    CASE WHEN destinations.access_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.access_key, $1::TEXT)
    ELSE ''
    END
  ) AS decrypted_destination_access_key,
  (
    CASE WHEN destinations.secret_key IS NOT NULL
    THEN pgp_sym_decrypt(destinations.secret_key, $1::TEXT)
    ELSE ''
    END
  ) AS decrypted_destination_secret_key
FROM executions
INNER JOIN backups ON backups.id = executions.backup_id
LEFT JOIN destinations ON destinations.id = backups.destination_id
WHERE executions.id = $2
`

type ExecutionsServiceGetExecutionForSoftDeleteParams struct {
	EncryptionKey string
	ExecutionID   uuid.UUID
}

type ExecutionsServiceGetExecutionForSoftDeleteRow struct {
	ExecutionID                   uuid.UUID
	ExecutionPath                 sql.NullString
	BackupID                      uuid.UUID
	BackupIsLocal                 bool
	DestinationBucketName         sql.NullString
	DestinationRegion             sql.NullString
	DestinationEndpoint           sql.NullString
	DestinationForcePathStyle     sql.NullBool
	DecryptedDestinationAccessKey string
	DecryptedDestinationSecretKey string
}

// file: /home/pgbackweb/internal/service/executions/soft_delete_execution.sql
func (q *Queries) ExecutionsServiceGetExecutionForSoftDelete(ctx context.Context, arg ExecutionsServiceGetExecutionForSoftDeleteParams) (ExecutionsServiceGetExecutionForSoftDeleteRow, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceGetExecutionForSoftDelete, arg.EncryptionKey, arg.ExecutionID)
	var i ExecutionsServiceGetExecutionForSoftDeleteRow
	err := row.Scan(
		&i.ExecutionID,
		&i.ExecutionPath,
		&i.BackupID,
		&i.BackupIsLocal,
		&i.DestinationBucketName,
		&i.DestinationRegion,
		&i.DestinationEndpoint,
		&i.DestinationForcePathStyle,
		&i.DecryptedDestinationAccessKey,
		&i.DecryptedDestinationSecretKey,
	)
	return i, err
}

const executionsServiceGetExecutionsQty = `-- name: ExecutionsServiceGetExecutionsQty :one
SELECT 
  COUNT(*) AS all,
  COALESCE(SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END), 0)::INTEGER AS running,
  COALESCE(SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END), 0)::INTEGER AS success,
  COALESCE(SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END), 0)::INTEGER AS failed,
  COALESCE(SUM(CASE WHEN status = 'deleted' THEN 1 ELSE 0 END), 0)::INTEGER AS deleted
FROM executions
`

type ExecutionsServiceGetExecutionsQtyRow struct {
	All     int64
	Running int32
	Success int32
	Failed  int32
	Deleted int32
}

// file: /home/pgbackweb/internal/service/executions/get_executions_qty.sql
func (q *Queries) ExecutionsServiceGetExecutionsQty(ctx context.Context) (ExecutionsServiceGetExecutionsQtyRow, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceGetExecutionsQty)
	var i ExecutionsServiceGetExecutionsQtyRow
	err := row.Scan(
		&i.All,
		&i.Running,
		&i.Success,
		&i.Failed,
		&i.Deleted,
	)
	return i, err
}

const executionsServiceGetExpiredExecutions = `-- name: ExecutionsServiceGetExpiredExecutions :many
SELECT executions.id, executions.backup_id, executions.status, executions.message, executions.path, executions.started_at, executions.updated_at, executions.finished_at, executions.deleted_at, executions.file_size
FROM executions
JOIN backups ON executions.backup_id = backups.id
WHERE
  backups.retention_days > 0
  AND executions.status != 'deleted'
  AND executions.finished_at IS NOT NULL
  AND (
    executions.finished_at + (backups.retention_days || ' days')::INTERVAL
  ) < NOW()
`

// file: /home/pgbackweb/internal/service/executions/soft_delete_expired_executions.sql
func (q *Queries) ExecutionsServiceGetExpiredExecutions(ctx context.Context) ([]Execution, error) {
	rows, err := q.db.QueryContext(ctx, executionsServiceGetExpiredExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Execution
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.BackupID,
			&i.Status,
			&i.Message,
			&i.Path,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.DeletedAt,
			&i.FileSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const executionsServiceListBackupExecutions = `-- name: ExecutionsServiceListBackupExecutions :many
SELECT id, backup_id, status, message, path, started_at, updated_at, finished_at, deleted_at, file_size FROM executions
WHERE backup_id = $1
ORDER BY started_at DESC
`

// file: /home/pgbackweb/internal/service/executions/list_backup_executions.sql
func (q *Queries) ExecutionsServiceListBackupExecutions(ctx context.Context, backupID uuid.UUID) ([]Execution, error) {
	rows, err := q.db.QueryContext(ctx, executionsServiceListBackupExecutions, backupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Execution
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.BackupID,
			&i.Status,
			&i.Message,
			&i.Path,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.DeletedAt,
			&i.FileSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const executionsServicePaginateExecutions = `-- name: ExecutionsServicePaginateExecutions :many
SELECT
  executions.id, executions.backup_id, executions.status, executions.message, executions.path, executions.started_at, executions.updated_at, executions.finished_at, executions.deleted_at, executions.file_size,
  backups.name AS backup_name,
  databases.name AS database_name,
  databases.pg_version AS database_pg_version,
  destinations.name AS destination_name,
  backups.is_local AS backup_is_local
FROM executions
INNER JOIN backups ON backups.id = executions.backup_id
INNER JOIN databases ON databases.id = backups.database_id
LEFT JOIN destinations ON destinations.id = backups.destination_id
WHERE
(
  $1::UUID IS NULL
  OR
  backups.id = $1::UUID
)
AND
(
  $2::UUID IS NULL
  OR
  databases.id = $2::UUID
)
AND
(
  $3::UUID IS NULL
  OR
  destinations.id = $3::UUID
)
ORDER BY executions.started_at DESC
LIMIT $5 OFFSET $4
`

type ExecutionsServicePaginateExecutionsParams struct {
	BackupID      uuid.NullUUID
	DatabaseID    uuid.NullUUID
	DestinationID uuid.NullUUID
	Offset        int32
	Limit         int32
}

type ExecutionsServicePaginateExecutionsRow struct {
	ID                uuid.UUID
	BackupID          uuid.UUID
	Status            string
	Message           sql.NullString
	Path              sql.NullString
	StartedAt         time.Time
	UpdatedAt         sql.NullTime
	FinishedAt        sql.NullTime
	DeletedAt         sql.NullTime
	FileSize          sql.NullInt64
	BackupName        string
	DatabaseName      string
	DatabasePgVersion string
	DestinationName   sql.NullString
	BackupIsLocal     bool
}

// file: /home/pgbackweb/internal/service/executions/paginate_executions.sql
func (q *Queries) ExecutionsServicePaginateExecutions(ctx context.Context, arg ExecutionsServicePaginateExecutionsParams) ([]ExecutionsServicePaginateExecutionsRow, error) {
	rows, err := q.db.QueryContext(ctx, executionsServicePaginateExecutions,
		arg.BackupID,
		arg.DatabaseID,
		arg.DestinationID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExecutionsServicePaginateExecutionsRow
	for rows.Next() {
		var i ExecutionsServicePaginateExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.BackupID,
			&i.Status,
			&i.Message,
			&i.Path,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.DeletedAt,
			&i.FileSize,
			&i.BackupName,
			&i.DatabaseName,
			&i.DatabasePgVersion,
			&i.DestinationName,
			&i.BackupIsLocal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const executionsServicePaginateExecutionsCount = `-- name: ExecutionsServicePaginateExecutionsCount :one
SELECT COUNT(executions.*)
FROM executions
INNER JOIN backups ON backups.id = executions.backup_id
INNER JOIN databases ON databases.id = backups.database_id
LEFT JOIN destinations ON destinations.id = backups.destination_id
WHERE
(
  $1::UUID IS NULL
  OR
  backups.id = $1::UUID
)
AND
(
  $2::UUID IS NULL
  OR
  databases.id = $2::UUID
)
AND
(
  $3::UUID IS NULL
  OR
  destinations.id = $3::UUID
)
`

type ExecutionsServicePaginateExecutionsCountParams struct {
	BackupID      uuid.NullUUID
	DatabaseID    uuid.NullUUID
	DestinationID uuid.NullUUID
}

// file: /home/pgbackweb/internal/service/executions/paginate_executions.sql
func (q *Queries) ExecutionsServicePaginateExecutionsCount(ctx context.Context, arg ExecutionsServicePaginateExecutionsCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, executionsServicePaginateExecutionsCount, arg.BackupID, arg.DatabaseID, arg.DestinationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const executionsServiceSoftDeleteExecution = `-- name: ExecutionsServiceSoftDeleteExecution :exec
UPDATE executions
SET
  status = 'deleted',
  deleted_at = NOW()
WHERE id = $1
`

// file: /home/pgbackweb/internal/service/executions/soft_delete_execution.sql
func (q *Queries) ExecutionsServiceSoftDeleteExecution(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, executionsServiceSoftDeleteExecution, id)
	return err
}

const executionsServiceUpdateExecution = `-- name: ExecutionsServiceUpdateExecution :one
UPDATE executions
SET
  status = COALESCE($1, status),
  message = COALESCE($2, message),
  path = COALESCE($3, path),
  finished_at = COALESCE($4, finished_at),
  deleted_at = COALESCE($5, deleted_at),
  file_size = COALESCE($6, file_size)
WHERE id = $7
RETURNING id, backup_id, status, message, path, started_at, updated_at, finished_at, deleted_at, file_size
`

type ExecutionsServiceUpdateExecutionParams struct {
	Status     sql.NullString
	Message    sql.NullString
	Path       sql.NullString
	FinishedAt sql.NullTime
	DeletedAt  sql.NullTime
	FileSize   sql.NullInt64
	ID         uuid.UUID
}

// file: /home/pgbackweb/internal/service/executions/update_execution.sql
func (q *Queries) ExecutionsServiceUpdateExecution(ctx context.Context, arg ExecutionsServiceUpdateExecutionParams) (Execution, error) {
	row := q.db.QueryRowContext(ctx, executionsServiceUpdateExecution,
		arg.Status,
		arg.Message,
		arg.Path,
		arg.FinishedAt,
		arg.DeletedAt,
		arg.FileSize,
		arg.ID,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.BackupID,
		&i.Status,
		&i.Message,
		&i.Path,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.DeletedAt,
		&i.FileSize,
	)
	return i, err
}

const restorationsServiceCreateRestoration = `-- name: RestorationsServiceCreateRestoration :one
INSERT INTO restorations (execution_id, database_id, status, message)
VALUES ($1, $2, $3, $4)
RETURNING id, execution_id, database_id, status, message, started_at, updated_at, finished_at
`

type RestorationsServiceCreateRestorationParams struct {
	ExecutionID uuid.UUID
	DatabaseID  uuid.NullUUID
	Status      string
	Message     sql.NullString
}

// file: /home/pgbackweb/internal/service/restorations/create_restoration.sql
func (q *Queries) RestorationsServiceCreateRestoration(ctx context.Context, arg RestorationsServiceCreateRestorationParams) (Restoration, error) {
	row := q.db.QueryRowContext(ctx, restorationsServiceCreateRestoration,
		arg.ExecutionID,
		arg.DatabaseID,
		arg.Status,
		arg.Message,
	)
	var i Restoration
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.DatabaseID,
		&i.Status,
		&i.Message,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const restorationsServiceGetRestorationsQty = `-- name: RestorationsServiceGetRestorationsQty :one
SELECT 
  COUNT(*) AS all,
  COALESCE(SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END), 0)::INTEGER AS running,
  COALESCE(SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END), 0)::INTEGER AS success,
  COALESCE(SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END), 0)::INTEGER AS failed
FROM restorations
`

type RestorationsServiceGetRestorationsQtyRow struct {
	All     int64
	Running int32
	Success int32
	Failed  int32
}

// file: /home/pgbackweb/internal/service/restorations/get_restorations_qty.sql
func (q *Queries) RestorationsServiceGetRestorationsQty(ctx context.Context) (RestorationsServiceGetRestorationsQtyRow, error) {
	row := q.db.QueryRowContext(ctx, restorationsServiceGetRestorationsQty)
	var i RestorationsServiceGetRestorationsQtyRow
	err := row.Scan(
		&i.All,
		&i.Running,
		&i.Success,
		&i.Failed,
	)
	return i, err
}

const restorationsServicePaginateRestorations = `-- name: RestorationsServicePaginateRestorations :many
SELECT
  restorations.id, restorations.execution_id, restorations.database_id, restorations.status, restorations.message, restorations.started_at, restorations.updated_at, restorations.finished_at,
  databases.name AS database_name,
  backups.name AS backup_name
FROM restorations
INNER JOIN executions ON executions.id = restorations.execution_id
INNER JOIN backups ON backups.id = executions.backup_id
LEFT JOIN databases ON databases.id = restorations.database_id
WHERE
(
  $1::UUID IS NULL
  OR
  restorations.execution_id = $1::UUID
)
AND
(
  $2::UUID IS NULL
  OR
  restorations.database_id = $2::UUID
)
ORDER BY restorations.started_at DESC
LIMIT $4 OFFSET $3
`

type RestorationsServicePaginateRestorationsParams struct {
	ExecutionID uuid.NullUUID
	DatabaseID  uuid.NullUUID
	Offset      int32
	Limit       int32
}

type RestorationsServicePaginateRestorationsRow struct {
	ID           uuid.UUID
	ExecutionID  uuid.UUID
	DatabaseID   uuid.NullUUID
	Status       string
	Message      sql.NullString
	StartedAt    time.Time
	UpdatedAt    sql.NullTime
	FinishedAt   sql.NullTime
	DatabaseName sql.NullString
	BackupName   string
}

// file: /home/pgbackweb/internal/service/restorations/paginate_restorations.sql
func (q *Queries) RestorationsServicePaginateRestorations(ctx context.Context, arg RestorationsServicePaginateRestorationsParams) ([]RestorationsServicePaginateRestorationsRow, error) {
	rows, err := q.db.QueryContext(ctx, restorationsServicePaginateRestorations,
		arg.ExecutionID,
		arg.DatabaseID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestorationsServicePaginateRestorationsRow
	for rows.Next() {
		var i RestorationsServicePaginateRestorationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.DatabaseID,
			&i.Status,
			&i.Message,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.DatabaseName,
			&i.BackupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restorationsServicePaginateRestorationsCount = `-- name: RestorationsServicePaginateRestorationsCount :one
SELECT COUNT(restorations.*)
FROM restorations
INNER JOIN executions ON executions.id = restorations.execution_id
INNER JOIN backups ON backups.id = executions.backup_id
LEFT JOIN databases ON databases.id = restorations.database_id
WHERE
(
  $1::UUID IS NULL
  OR
  restorations.execution_id = $1::UUID
)
AND
(
  $2::UUID IS NULL
  OR
  restorations.database_id = $2::UUID
)
`

type RestorationsServicePaginateRestorationsCountParams struct {
	ExecutionID uuid.NullUUID
	DatabaseID  uuid.NullUUID
}

// file: /home/pgbackweb/internal/service/restorations/paginate_restorations.sql
func (q *Queries) RestorationsServicePaginateRestorationsCount(ctx context.Context, arg RestorationsServicePaginateRestorationsCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, restorationsServicePaginateRestorationsCount, arg.ExecutionID, arg.DatabaseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const restorationsServiceUpdateRestoration = `-- name: RestorationsServiceUpdateRestoration :one
UPDATE restorations
SET
  status = COALESCE($1, status),
  message = COALESCE($2, message),
  finished_at = COALESCE($3, finished_at)
WHERE id = $4
RETURNING id, execution_id, database_id, status, message, started_at, updated_at, finished_at
`

type RestorationsServiceUpdateRestorationParams struct {
	Status     sql.NullString
	Message    sql.NullString
	FinishedAt sql.NullTime
	ID         uuid.UUID
}

// file: /home/pgbackweb/internal/service/restorations/update_restoration.sql
func (q *Queries) RestorationsServiceUpdateRestoration(ctx context.Context, arg RestorationsServiceUpdateRestorationParams) (Restoration, error) {
	row := q.db.QueryRowContext(ctx, restorationsServiceUpdateRestoration,
		arg.Status,
		arg.Message,
		arg.FinishedAt,
		arg.ID,
	)
	var i Restoration
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.DatabaseID,
		&i.Status,
		&i.Message,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const usersServiceChangePassword = `-- name: UsersServiceChangePassword :exec
UPDATE users
SET password = $1
WHERE id = $2
`

type UsersServiceChangePasswordParams struct {
	Password string
	ID       uuid.UUID
}

// file: /home/pgbackweb/internal/service/users/change_password.sql
func (q *Queries) UsersServiceChangePassword(ctx context.Context, arg UsersServiceChangePasswordParams) error {
	_, err := q.db.ExecContext(ctx, usersServiceChangePassword, arg.Password, arg.ID)
	return err
}

const usersServiceCreateUser = `-- name: UsersServiceCreateUser :one
INSERT INTO users (name, email, password)
VALUES ($1, lower($2), $3)
RETURNING id, name, email, password, created_at, updated_at
`

type UsersServiceCreateUserParams struct {
	Name     string
	Email    string
	Password string
}

// file: /home/pgbackweb/internal/service/users/create_user.sql
func (q *Queries) UsersServiceCreateUser(ctx context.Context, arg UsersServiceCreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, usersServiceCreateUser, arg.Name, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const usersServiceGetUserByEmail = `-- name: UsersServiceGetUserByEmail :one
SELECT id, name, email, password, created_at, updated_at FROM users WHERE email = $1
`

// file: /home/pgbackweb/internal/service/users/get_user_by_email.sql
func (q *Queries) UsersServiceGetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, usersServiceGetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const usersServiceGetUsersQty = `-- name: UsersServiceGetUsersQty :one
SELECT COUNT(*) FROM users
`

// file: /home/pgbackweb/internal/service/users/get_users_qty.sql
func (q *Queries) UsersServiceGetUsersQty(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, usersServiceGetUsersQty)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const usersServiceUpdateUser = `-- name: UsersServiceUpdateUser :one
UPDATE users
SET
  name = COALESCE($1, name),
  email = lower(COALESCE($2, email)),
  password = COALESCE($3, password)
WHERE id = $4
RETURNING id, name, email, password, created_at, updated_at
`

type UsersServiceUpdateUserParams struct {
	Name     sql.NullString
	Email    interface{}
	Password sql.NullString
	ID       uuid.UUID
}

// file: /home/pgbackweb/internal/service/users/update_user.sql
func (q *Queries) UsersServiceUpdateUser(ctx context.Context, arg UsersServiceUpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, usersServiceUpdateUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const webhooksServiceCreateWebhook = `-- name: WebhooksServiceCreateWebhook :one
INSERT INTO webhooks (
  name, is_active, event_type, target_ids,
  url, method, headers, body
) VALUES (
  $1, $2, $3, $4,
  $5, $6, $7, $8
) RETURNING id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at
`

type WebhooksServiceCreateWebhookParams struct {
	Name      string
	IsActive  bool
	EventType string
	TargetIds []uuid.UUID
	Url       string
	Method    string
	Headers   sql.NullString
	Body      sql.NullString
}

// file: /home/pgbackweb/internal/service/webhooks/create_webhook.sql
func (q *Queries) WebhooksServiceCreateWebhook(ctx context.Context, arg WebhooksServiceCreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, webhooksServiceCreateWebhook,
		arg.Name,
		arg.IsActive,
		arg.EventType,
		pq.Array(arg.TargetIds),
		arg.Url,
		arg.Method,
		arg.Headers,
		arg.Body,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.EventType,
		pq.Array(&i.TargetIds),
		&i.Url,
		&i.Method,
		&i.Headers,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const webhooksServiceCreateWebhookExecution = `-- name: WebhooksServiceCreateWebhookExecution :one
INSERT INTO webhook_executions (
  webhook_id, req_method, req_headers, req_body,
  res_status, res_headers, res_body, res_duration
)
VALUES (
  $1, $2, $3, $4,
  $5, $6, $7, $8
)
RETURNING id, webhook_id, req_method, req_headers, req_body, res_status, res_headers, res_body, res_duration, created_at
`

type WebhooksServiceCreateWebhookExecutionParams struct {
	WebhookID   uuid.UUID
	ReqMethod   sql.NullString
	ReqHeaders  sql.NullString
	ReqBody     sql.NullString
	ResStatus   sql.NullInt16
	ResHeaders  sql.NullString
	ResBody     sql.NullString
	ResDuration sql.NullInt32
}

// file: /home/pgbackweb/internal/service/webhooks/run_webhook.sql
func (q *Queries) WebhooksServiceCreateWebhookExecution(ctx context.Context, arg WebhooksServiceCreateWebhookExecutionParams) (WebhookExecution, error) {
	row := q.db.QueryRowContext(ctx, webhooksServiceCreateWebhookExecution,
		arg.WebhookID,
		arg.ReqMethod,
		arg.ReqHeaders,
		arg.ReqBody,
		arg.ResStatus,
		arg.ResHeaders,
		arg.ResBody,
		arg.ResDuration,
	)
	var i WebhookExecution
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ReqMethod,
		&i.ReqHeaders,
		&i.ReqBody,
		&i.ResStatus,
		&i.ResHeaders,
		&i.ResBody,
		&i.ResDuration,
		&i.CreatedAt,
	)
	return i, err
}

const webhooksServiceDeleteWebhook = `-- name: WebhooksServiceDeleteWebhook :exec
DELETE FROM webhooks WHERE id = $1
`

// file: /home/pgbackweb/internal/service/webhooks/delete_webhook.sql
func (q *Queries) WebhooksServiceDeleteWebhook(ctx context.Context, webhookID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, webhooksServiceDeleteWebhook, webhookID)
	return err
}

const webhooksServiceDuplicateWebhook = `-- name: WebhooksServiceDuplicateWebhook :one
INSERT INTO webhooks
SELECT (
  webhooks
  #= hstore('id', uuid_generate_v4()::text)
  #= hstore('name', (webhooks.name || ' (copy)')::text)
  #= hstore('is_active', false::text)
  #= hstore('created_at', now()::text)
  #= hstore('updated_at', now()::text)
).*
FROM webhooks
WHERE webhooks.id = $1
RETURNING id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at
`

// file: /home/pgbackweb/internal/service/webhooks/duplicate_webhook.sql
func (q *Queries) WebhooksServiceDuplicateWebhook(ctx context.Context, webhookID uuid.UUID) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, webhooksServiceDuplicateWebhook, webhookID)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.EventType,
		pq.Array(&i.TargetIds),
		&i.Url,
		&i.Method,
		&i.Headers,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const webhooksServiceGetWebhook = `-- name: WebhooksServiceGetWebhook :one
SELECT id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at FROM webhooks WHERE id = $1
`

// file: /home/pgbackweb/internal/service/webhooks/get_webhook.sql
func (q *Queries) WebhooksServiceGetWebhook(ctx context.Context, webhookID uuid.UUID) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, webhooksServiceGetWebhook, webhookID)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.EventType,
		pq.Array(&i.TargetIds),
		&i.Url,
		&i.Method,
		&i.Headers,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const webhooksServiceGetWebhooksToRun = `-- name: WebhooksServiceGetWebhooksToRun :many
SELECT id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at FROM webhooks
WHERE is_active = true
AND event_type = $1
AND $2::UUID = ANY(target_ids)
`

type WebhooksServiceGetWebhooksToRunParams struct {
	EventType string
	TargetID  uuid.UUID
}

// file: /home/pgbackweb/internal/service/webhooks/run_webhook.sql
func (q *Queries) WebhooksServiceGetWebhooksToRun(ctx context.Context, arg WebhooksServiceGetWebhooksToRunParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, webhooksServiceGetWebhooksToRun, arg.EventType, arg.TargetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.EventType,
			pq.Array(&i.TargetIds),
			&i.Url,
			&i.Method,
			&i.Headers,
			&i.Body,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const webhooksServicePaginateWebhookExecutions = `-- name: WebhooksServicePaginateWebhookExecutions :many
SELECT id, webhook_id, req_method, req_headers, req_body, res_status, res_headers, res_body, res_duration, created_at FROM webhook_executions
WHERE webhook_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type WebhooksServicePaginateWebhookExecutionsParams struct {
	WebhookID uuid.UUID
	Offset    int32
	Limit     int32
}

// file: /home/pgbackweb/internal/service/webhooks/paginate_webhook_executions.sql
func (q *Queries) WebhooksServicePaginateWebhookExecutions(ctx context.Context, arg WebhooksServicePaginateWebhookExecutionsParams) ([]WebhookExecution, error) {
	rows, err := q.db.QueryContext(ctx, webhooksServicePaginateWebhookExecutions, arg.WebhookID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookExecution
	for rows.Next() {
		var i WebhookExecution
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.ReqMethod,
			&i.ReqHeaders,
			&i.ReqBody,
			&i.ResStatus,
			&i.ResHeaders,
			&i.ResBody,
			&i.ResDuration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const webhooksServicePaginateWebhookExecutionsCount = `-- name: WebhooksServicePaginateWebhookExecutionsCount :one
SELECT COUNT(*) FROM webhook_executions
WHERE webhook_id = $1
`

// file: /home/pgbackweb/internal/service/webhooks/paginate_webhook_executions.sql
func (q *Queries) WebhooksServicePaginateWebhookExecutionsCount(ctx context.Context, webhookID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, webhooksServicePaginateWebhookExecutionsCount, webhookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const webhooksServicePaginateWebhooks = `-- name: WebhooksServicePaginateWebhooks :many
SELECT id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at FROM webhooks
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type WebhooksServicePaginateWebhooksParams struct {
	Offset int32
	Limit  int32
}

// file: /home/pgbackweb/internal/service/webhooks/paginate_webhooks.sql
func (q *Queries) WebhooksServicePaginateWebhooks(ctx context.Context, arg WebhooksServicePaginateWebhooksParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, webhooksServicePaginateWebhooks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.EventType,
			pq.Array(&i.TargetIds),
			&i.Url,
			&i.Method,
			&i.Headers,
			&i.Body,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const webhooksServicePaginateWebhooksCount = `-- name: WebhooksServicePaginateWebhooksCount :one
SELECT COUNT(*) FROM webhooks
`

// file: /home/pgbackweb/internal/service/webhooks/paginate_webhooks.sql
func (q *Queries) WebhooksServicePaginateWebhooksCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, webhooksServicePaginateWebhooksCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const webhooksServiceUpdateWebhook = `-- name: WebhooksServiceUpdateWebhook :one
UPDATE webhooks
SET
  name = COALESCE($1, name),
  is_active = COALESCE($2, is_active),
  event_type = COALESCE($3, event_type),
  target_ids = COALESCE($4, target_ids),
  url = COALESCE($5, url),
  method = COALESCE($6, method),
  headers = COALESCE($7, headers),
  body = COALESCE($8, body)
WHERE id = $9
RETURNING id, name, is_active, event_type, target_ids, url, method, headers, body, created_at, updated_at
`

type WebhooksServiceUpdateWebhookParams struct {
	Name      sql.NullString
	IsActive  sql.NullBool
	EventType sql.NullString
	TargetIds []uuid.UUID
	Url       sql.NullString
	Method    sql.NullString
	Headers   sql.NullString
	Body      sql.NullString
	WebhookID uuid.UUID
}

// file: /home/pgbackweb/internal/service/webhooks/update_webhook.sql
func (q *Queries) WebhooksServiceUpdateWebhook(ctx context.Context, arg WebhooksServiceUpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, webhooksServiceUpdateWebhook,
		arg.Name,
		arg.IsActive,
		arg.EventType,
		pq.Array(arg.TargetIds),
		arg.Url,
		arg.Method,
		arg.Headers,
		arg.Body,
		arg.WebhookID,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.EventType,
		pq.Array(&i.TargetIds),
		&i.Url,
		&i.Method,
		&i.Headers,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
